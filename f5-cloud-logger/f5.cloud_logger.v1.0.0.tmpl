sys application template f5.cloud_logger.v1.0.0 {
    actions {
        definition {
            html-help {
                <p><strong>F5 Cloud Logging and Analytics iApp</strong></p>

<p>This template creates a set of configuration objects to enable logging and analytics to external solutions</p>
            }
            implementation {
	## Define some proc(s) for use in implementation
	proc tmsh_exe { command } {
		puts $command
		exec /usr/bin/tmsh -c $command
	}
	proc format_jsonlist { input } {
		regsub -all "\"|\\\]|\\\[|\n" $input "" input
		regsub -all "," $input " " input
		return $input
	}
	proc format_poolmembers {input} {
		set poolmembers ""
		set dataset [split [format_jsonlist $input] " "]
		foreach item $dataset {
			set member [split $item ":"]
			# Check to see if this is an IP or FQDN
			if {[regexp {^((([2][5][0-5]|([2][0-4]|[1][0-9]|[0-9])?[0-9])\.){3})([2][5][0-5]|([2][0-4]|[1][0-9]|[0-9])?[0-9])$} [lindex $member 0]]} {
				append poolmembers "mbr-$item \{ address [lindex $member 0] \}"
			} else {
				# Must be FQDN - let tmsh do validation
				append poolmembers "mbr-$item \{ fqdn \{ autopopulate enabled name [lindex $member 0] \} \}"
			}
		}
		return $poolmembers
	}
	proc format_req_logging {input} {
		# Format the input as key/value pairs in the same format as the "splunk" keyword on the BIG-IP
		set req_template EVENT_SOURCE=\\\"request_logging\\\",BIGIP_HOSTNAME=\\\"\$BIGIP_HOSTNAME\\\"
		foreach item $input {
			append req_template ,${item}=\\\"\$${item}\\\"
		}
		return $req_template
	}

	package require iapp 1.3.0
	iapp::template start

	######## Start iRules Declaration ########
	######## Format iRule ########
	set format_ir {
proc format_msg msg {
	set mgmt_hostname <MGMT_HOSTNAME>
	set mgmt_port <MGMT_PORT>
	set date [clock format [clock seconds] -format "%a, %d %b %Y %H:%M:%S GMT" -gmt true]
	# If ASM strip up to ASM:unit from start
	if {[set asm [string first "ASM:unit" $msg]] >= 0}{
		set msg [string range $msg $asm [string length $msg]]
		set msg "\"${msg}"
		regsub -all "=\"" $msg "\":\"" msg
		regsub -all "\"," $msg "\",\"" msg

	# extract all the info we need to send
	if {[string first "support_id" $msg] >= 0} {
		set supportid [findstr $msg "support_id" 13 "\""]
	} else {
		set supportid "N/A"
	}
	# set remediation link if support ID exists
	set remediation_link "[expr { $supportid ne "N/A" ? "<REMED_LINK>" : "N/A" }]"

	set final_msg "\[\{\"time\":\"$date\",\"host\":\"$static::tcl_platform(machine)\",\"logSource\":\"ASM\",\"bigipVersion\":\"$static::tcl_platform(osVersion)\",\"remediationLink\":\"$remediation_link\",$msg\}\]"
	} else {
		# Format message as JSON
		set msg "\"${msg}"
		regsub -all "=\"" $msg "\":\"" msg
		regsub -all "\"," $msg "\",\"" msg
		set final_msg "\[\{\"time\":\"$date\",\"host\":\"$static::tcl_platform(machine)\",\"logSource\":\"BIGIP\",\"bigipVersion\":\"$static::tcl_platform(osVersion)\",$msg\}\]"
	}
	<EXTRA_FORMAT>
	return $final_msg
}
proc configure_auth {final_msg access_key secret_key date host region} {
	# Handle Creation of Authentication Token
	<CONFIGURE_AUTH>
	return $signed_string
}
proc get_secret_key {} {
    set secret_key ""
    # Grab secret_key which should exist in table entry
	for {set i 0} { $i < 50 } {incr i} {
        if { [table lookup <IAPP_NAME>_secret_key] != "" } {
			# Grab secret_key
            set secret_key [table lookup <IAPP_NAME>_secret_key]

			# Don't log plaintext credential to log location even if debug is enabled
            #call logger "Decoded credential secret: $secret_key" 0
			call logger "Secret Key table entry exists" 0
            break
        } else {
            # Keep trying after delay until loop expires
            after 10
        }
	}
	if { $secret_key == "" } {
		call logger "Error: Secret Key table entry empty" 2
	}
	return $secret_key
}
proc logger {msg level} {
	# Generic logger with level to determine what to log
	# Log if level is higher than what is set by user
	# Levels are 0=debug, 1=info, 2=error
	set loglevel <LOG_LEVEL>
	if {$level < $loglevel} { return }
	# Syslog facility is limited to 1024 characters, anything longer is truncated in the logs
	# Loop through and log each chunk of the msg
	set max_chars 900
	set remaining $msg
	set count 1
	if {[string length $remaining] < $max_chars}{
		# no need to chunk if total msg is less than max_chars
		log local0.info "$msg"
		return
	}
	while {[string length $remaining] > $max_chars}{
		# Get the current chunk to log
		set current [string range $remaining 0 [expr { $max_chars - 1}]]
		log local0.info "chunk ${count}=${current}"
		# Get the next chunk to log
		set remaining [string range $remaining $max_chars end]
		incr count
	}
	if {[string length $remaining]}{
		log local0.info "chunk ${count}=${remaining}"
	}
	return
}
when RULE_INIT {
     # SOL14544 workaround
     upvar #0 tcl_platform static::tcl_platform
}

when CLIENT_ACCEPTED {
	# Base variables
	set ctx(log_type) <LOG_TYPE>
	# Construct full path to API endpoint
	set ctx(customer_id) "<WORKSPACE>"
	set ctx(host) "<ANALYTICS_HOSTNAME>"
	set ctx(full_path) "<ANALYTICS_PATH>"
	# Need to put this somewhere less visible
	set ctx(access_key) "<KEY>"
	set ctx(secret_key) [call get_secret_key]
	set ctx(region) "<REGION>"
	# Collect and process in CLIENT_DATA
	set buf "\n"
	TCP::collect
}

when CLIENT_DATA {
     if {[string length $buf] == 0} { set buf "\n" }
     append buf [TCP::payload]

     TCP::payload replace 0 [TCP::payload length] ""
     TCP::collect
     # Note: don't call TCP::release here because that will reset
     # the TCP connection since we don't have a pool.  If we just
     # keep calling TCP:::collect we can go on indefinitely
     while {[set dex [string first "\n" $buf]] >= 0 } {
          if {[set d2x [string first "\n" $buf [expr {$dex + 1}]]] < 0} {
               # Unsure buf contains a complete message yet
               break
          }
          # Open HSL connection since we have a msg to send
		  set hslpool [HSL::open -proto TCP -pool "<HSL_POOL>"]
          # Pull first complete msg from buf
          set rawmsg [string range $buf [expr {$dex +1 }] [expr {$d2x - 1}]]
		  # Remove this msg from buf
		  set buf [string range $buf [expr {$d2x +1 }] end]

		  set final_msg [call format_msg $rawmsg]
		  set date <DATE_CMD>
		  <EXTRA_CMDS>
		  # Handle Auth Token
		  set auth_token [call configure_auth $final_msg $ctx(access_key) $ctx(secret_key) $date $ctx(host) $ctx(region)]
		  # Compile full HTTP Post
          set fullPOST "<ANALYTICS_POST>"

		  call logger "Full HTTP Post: $fullPOST" 0
		  # Send message to Send VS
          catch {HSL::send $hslpool $fullPOST}
     }
     # any trailing partial message stays in buffer until next packet
     # arrives or incoming TCP connection is closed
}

when CLIENT_CLOSED {
	# deal with final message in buffer
	if {[set dex [string first "\n" $buf]] >= 1} {
	# Open HSL connection since we have a msg to send
	set hslpool [HSL::open -proto TCP -pool "<HSL_POOL>"]

	set final_msg [call format_msg $buf]
	set date <DATE_CMD>
	<EXTRA_CMDS>
	# Handle Auth
	set auth_token [call configure_auth $final_msg $ctx(access_key) $ctx(secret_key) $date $ctx(host) $ctx(region)]
	# Compile full HTTP Post
	set fullPOST "<ANALYTICS_POST>"

	call logger "Full HTTP Post: $fullPOST" 0
	# Send message to Send VS
	catch {HSL::send $hslpool $fullPOST}
	}
}
	}

	######## Send iRule ########
	set send_ir {
when HTTP_REQUEST {
	call <FMT_IRULE_NAME>::logger "Request: [HTTP::uri]" 1
    foreach header [HTTP::header names] {
	  call <FMT_IRULE_NAME>::logger "Header $header: [HTTP::header value $header]" 0
   }
}
when HTTP_RESPONSE {
    set status [HTTP::status]
    set content_length 0
    if {[HTTP::header "Content-Length"] ne ""}{
      set content_length [HTTP::header "Content-Length"]
    } elseif { $status != "200" } {
        set content_length 1048576
    }
	if { $content_length > 0 }{
		HTTP::collect $content_length
	}

    call <FMT_IRULE_NAME>::logger "Response: $status" 1
    foreach header [HTTP::header names] {
	  call <FMT_IRULE_NAME>::logger "Header $header: [HTTP::header value $header]" 0
    }
}
when HTTP_RESPONSE_DATA {
     set payload [HTTP::payload]
     HTTP::respond $status content $payload
     call <FMT_IRULE_NAME>::logger "Payload Data $content_length: $payload" 0
	 <TABLE_SEQ>
}
	}
	######## Credential iRule ########
	set cred_ir {
when HTTP_REQUEST {
    # Make sure this is the credentials monitor
    if { [HTTP::uri] == "/credentials" } {
        if { [HTTP::header exists Authorization] } {
            set decoded_secret [findstr [b64decode [findstr [HTTP::header Authorization] "Basic " 6]] "user:" 5]

            # Create/update table entry
            table set <IAPP_NAME>_secret_key $decoded_secret indefinite
            # Respond so monitor is up
            HTTP::respond 200
        } else {
            call <FMT_IRULE_NAME>::logger "Error: Authorization Header does not exist for credential monitor" 2
        }
    }
}
	}
	######## End iRules Declaration ########

	set app $tmsh::app_name
	set dynamic_mgmt_port [tmsh::get_field_value [lindex [tmsh::get_config "sys httpd ssl-port"] 0] "ssl-port"]
	set is_v13_0 [iapp::tmos_version >= 13.0]
	set path [tmsh::pwd]


	# Keys: $analytics_solution
	array set access_key_arr {
		azure_oms { none }
		aws_cw { $::analytics_config__access_key }
		aws_s3 { $::analytics_config__access_key }
		* { none }
	}
	array set secret_key_arr {
		azure_oms { $::analytics_config__shared_key }
		aws_cw { $::analytics_config__secret_key }
		aws_s3 { $::analytics_config__secret_key }
		* { none }
	}

	# Generic Variables
	set analytics_solution [expr { [info exists ::analytics_config__analytics_solution] ? "$::analytics_config__analytics_solution" : "azure_oms" }]
	set fqdn_suffix [expr { [iapp::is ::basic__advanced yes] && [iapp::is ::analytics_config__azure_env azureusgov] ? "us" : "com" }]
	set asm_log_choice [expr { [info exists ::logging_config__asm_log_choice] && [iapp::is ::logging_config__asm_log_choice yes] }]
	set dos_logs [expr { $asm_log_choice && [info exists ::logging_config__dos_logs] && [iapp::is ::logging_config__dos_logs yes] }]
	set apm_log_choice [expr { [info exists ::logging_config__apm_log_choice] && [iapp::is ::logging_config__apm_log_choice yes] }]
	set afm_log_choice [expr { [info exists ::logging_config__afm_log_choice] && [iapp::is ::logging_config__afm_log_choice yes] }]
	set ltm_req_log_choice [expr { [info exists ::logging_config__ltm_req_log_choice] && [iapp::is ::logging_config__ltm_req_log_choice yes] }]
	set mgmt_hostname [expr { [iapp::is ::internal_config__hostname custom] ? "$::internal_config__mgmt_hostname" : {$static::tcl_platform(machine)} }]
	set mgmt_port [expr { [iapp::is ::internal_config__port custom] ? "$::internal_config__mgmt_port" : "$dynamic_mgmt_port" }]
	set access_key [iapp::substa access_key_arr($analytics_solution)]
	set secret_key [iapp::substa secret_key_arr($analytics_solution)]
	set format_vs_port [expr { [iapp::is ::basic__advanced yes] && [info exists ::internal_config__internal_vs_port] ? $::internal_config__internal_vs_port : "41001" }]
	set send_vs_port [expr { $format_vs_port + 1 }]
	set cred_vs_port [expr { $format_vs_port + 2 }]
	set log_level [expr { [iapp::is ::basic__advanced yes] && [info exists ::internal_config__irule_log_level] ? "$::internal_config__irule_log_level" : "2" }]
	set remediation_link [expr { $is_v13_0 ? {https://${mgmt_hostname}:${mgmt_port}/dms/policy/requests_ng.php?popup\=1&supportId\=${supportid}} : {https://${mgmt_hostname}:${mgmt_port}/dms/policy/win_open_proxy_request.php?id\=&support_id\=${supportid}} }]
	# Azure OMS Variables
	set workspace [expr { [info exists ::analytics_config__workspace] ? "$::analytics_config__workspace" : "none" }]
	set log_type [expr { [info exists ::analytics_config__log_type] ? "$::analytics_config__log_type" : "F5CustomLogs" }]
	# AWS CloudWatch Variables
	set aws_region [expr { [info exists ::analytics_config__aws_region] ? "$::analytics_config__aws_region" : "none" }]
	set log_group_name [expr { [info exists ::analytics_config__log_group_name] ? "$::analytics_config__log_group_name" : "ASMLogs" }]
	set log_stream_name [expr { [info exists ::analytics_config__log_stream_name] ? "$::analytics_config__log_stream_name" : "ASMStream01" }]
	set s3_bucket_name [expr { [info exists ::analytics_config__s3_bucket_name] ? "$::analytics_config__s3_bucket_name" : "S3Bucket" }]

	# create SSL cert for logging virtual server SSL
	catch { tmsh_exe "create sys crypto key ${app}_send_vs_cert gen-certificate common-name Cloud_Analytics_Logging country US lifetime 3650" }

	## Account for uniqueness in the iRule(s) based on which analytics solution it is using
	# Keys: $analytics_solution
	array set host_arr {
		azure_oms 			{ ${workspace}.ods.opinsights.azure.${fqdn_suffix} }
		aws_cw 				{ logs.${aws_region}.amazonaws.com }
		aws_s3 				{ ${s3_bucket_name}.s3.amazonaws.com }
		* 					{ none }
	}
	# Keys: $analytics_solution
	array set path_arr {
		azure_oms 			{/api/logs?api-version=2016-04-01}
		aws_cw 				{/}
		aws_s3 				{/}
		* 					{/}
	}
	# Keys: $analytics_solution
	array set post_arr {
		azure_oms 			{POST ${ctx(full_path)} HTTP/1.1\nHost: ${ctx(host)}\nContent-Type: application/json\nAuthorization: SharedKey ${ctx(customer_id)}:$auth_token\nContent-Length: [string length $final_msg]\nx-ms-date: $date\nLog-Type: ${ctx(log_type)}\n\n${final_msg}}
		aws_cw 				{POST ${ctx(full_path)} HTTP/1.1\nHost: ${ctx(host)}\nContent-Type: application/x-amz-json-1.1\nAuthorization: ${auth_token}\nX-Amz-Date: ${date}\nX-Amz-Target: Logs_20140328.PutLogEvents\nContent-Length: [string length $final_msg]\n\n${final_msg}}
		aws_s3 				{PUT /${date}.log HTTP/1.1\nHost: ${ctx(host)}\nContent-Type: application/json\nx-amz-content-sha256: ${payload_hash}\nAuthorization: ${auth_token}\nX-Amz-Date: ${date}\nx-amz-meta-author: BIG-IP\nContent-Length: [string length $final_msg]\n\n${final_msg}}
		* 					{POST /}
	}
	# Keys: $analytics_solution
	array set extra_fmt_arr {
		aws_cw 			{set epoch_date [expr [clock seconds] * 1000]
	set log_group_name "<LOG_GROUP_NAME>"
	set log_stream_name "<LOG_STREAM_NAME>"
	# Account for this being JSON inside of JSON
	regsub -all "\"" $final_msg "\\\"" final_msg
	regsub -all "\\n" $final_msg "" final_msg
	regsub -all "\\r" $final_msg "" final_msg
	## Handle Sequence Token
	# Check if token is available before using
	set seq_token ""
	set t 50
	# A little too verbose even for debug
	#call logger "Seq Token Status: [table lookup <IAPP_NAME>_seq_token_status]" 0
	for {set i 0} { $i < $t } {incr i} {
        if { [table lookup <IAPP_NAME>_seq_token_status] == "busy" } {
            # Keep trying after delay
            after 10
        } else {
            # Sequence token is available, grab it and break from loop
            table set <IAPP_NAME>_seq_token_status "busy"
            set seq_token [table lookup <IAPP_NAME>_seq_token]
            break
        }
	}
	if { $seq_token equals "" } {
		set seq_token null
	} else {
		set seq_token \"$seq_token\"
	}
	set final_msg "\{\"sequenceToken\":${seq_token},\"logGroupName\":\"${log_group_name}\",\"logStreamName\":\"${log_stream_name}\",\"logEvents\":\[\{\"timestamp\":${epoch_date},\"message\":\"${final_msg}\"\}\]\}"}
		aws_s3 			{# Return final_msg
		}
		azure_oms 		{# Return final_msg
		}
		* 				{# Return final_msg
		}
	}
	# Keys: $analytics_solution
	array set auth_proc_arr {
		azure_oms 		{set str_to_sign "POST\n[string length $final_msg]\napplication/json\nx-ms-date:$date\n/api/logs"
	set decoded_key [b64decode $secret_key]
	set token [CRYPTO::sign -alg hmac-sha256 -key $decoded_key $str_to_sign]
	set signed_string [b64encode ${token}]
	}
		aws_cw 			{set date_stamp [clock format [clock seconds] -format "%Y%m%d" -gmt true]
	binary scan [CRYPTO::hash -alg sha256 $final_msg] H* payload_hash
	set signed_headers "content-type;host;x-amz-date;x-amz-target"
	set req_headers "content-type:application/x-amz-json-1.1\nhost:${host}\nx-amz-date:${date}\nx-amz-target:Logs_20140328.PutLogEvents\n"
	set request "POST\n/\n\n${req_headers}\n${signed_headers}\n${payload_hash}"
	set algorithm "AWS4-HMAC-SHA256"
	set service "logs"
	set cred_scope "${date_stamp}/${region}/${service}/aws4_request"
	binary scan [CRYPTO::hash -alg sha256 $request] H* request_hash
	set str_to_sign "${algorithm}\n${date}\n${cred_scope}\n${request_hash}"

	set kDate [CRYPTO::sign -alg hmac-sha256 -key AWS4${secret_key} $date_stamp]
	set kRegion [CRYPTO::sign -alg hmac-sha256 -key $kDate $region]
	set kService [CRYPTO::sign -alg hmac-sha256 -key $kRegion $service]
	set kSigning [CRYPTO::sign -alg hmac-sha256 -key $kService aws4_request]
	binary scan [CRYPTO::sign -alg hmac-sha256 -key $kSigning $str_to_sign] H* auth_token
	set signed_string "${algorithm} Credential=${access_key}/${cred_scope}, SignedHeaders=${signed_headers}, Signature=${auth_token}"
	}
		aws_s3 			{set date_stamp [clock format [clock seconds] -format "%Y%m%d" -gmt true]
	binary scan [CRYPTO::hash -alg sha256 $final_msg] H* payload_hash
	set signed_headers "content-type;host;x-amz-content-sha256;x-amz-date;x-amz-meta-author"
	set req_headers "content-type:application/json\nhost:${host}\nx-amz-content-sha256:${payload_hash}\nx-amz-date:${date}\nx-amz-meta-author:BIG-IP\n"
	set request "PUT\n/${date}.log\n\n${req_headers}\n${signed_headers}\n${payload_hash}"
	set algorithm "AWS4-HMAC-SHA256"
	set service "s3"
	set cred_scope "${date_stamp}/${region}/${service}/aws4_request"
	binary scan [CRYPTO::hash -alg sha256 $request] H* request_hash
	set str_to_sign "${algorithm}\n${date}\n${cred_scope}\n${request_hash}"

	set kDate [CRYPTO::sign -alg hmac-sha256 -key AWS4${secret_key} $date_stamp]
	set kRegion [CRYPTO::sign -alg hmac-sha256 -key $kDate $region]
	set kService [CRYPTO::sign -alg hmac-sha256 -key $kRegion $service]
	set kSigning [CRYPTO::sign -alg hmac-sha256 -key $kService aws4_request]
	binary scan [CRYPTO::sign -alg hmac-sha256 -key $kSigning $str_to_sign] H* auth_token
	set signed_string "${algorithm} Credential=${access_key}/${cred_scope}, SignedHeaders=${signed_headers}, Signature=${auth_token}"
	}
		* 				{set signed_string ""}
	}
	# Keys: $analytics_solution
	array set seq_table_arr {
		azure_oms 		{# Event end
		}
		aws_cw 			{
	# Handle AWS Sequence Token
	if {[set seq_token_loc [string first \"nextSequenceToken\":\" $payload]] >= 0}{
		set seq_token [string range $payload [expr $seq_token_loc + 21] [expr [string first \" $payload [expr $seq_token_loc + 21]] -1]]
	} elseif {[set seq_token_loc [string first \"expectedSequenceToken\":\" $payload]] >= 0}{
		set seq_token [string range $payload [expr $seq_token_loc + 25] [expr [string first \",\" $payload $seq_token_loc] -1]]
	} else {
		set seq_token ""
	}
	table set <IAPP_NAME>_seq_token $seq_token indefinite
	table set <IAPP_NAME>_seq_token_status "free"
	}
		aws_s3 		{# Event end
		}
		* 				{# Event end
		}
	}
	# Keys: $analytics_solution
	array set date_arr {
		azure_oms 		{[clock format [clock seconds] -format "%a, %d %b %Y %H:%M:%S GMT" -gmt true]}
		aws_cw 			{[clock format [clock seconds] -format "%Y%m%dT%H%M%SZ" -gmt true]}
		aws_s3 			{[clock format [clock seconds] -format "%Y%m%dT%H%M%SZ" -gmt true]}
		* 				{[clock format [clock seconds] -format "%a, %d %b %Y %H:%M:%S GMT" -gmt true]}
	}
	# Keys: $analytics_solution
	array set extra_cmd_arr {
		azure_oms 		{}
		aws_cw 			{}
		aws_s3 			{binary scan [CRYPTO::hash -alg sha256 $final_msg] H* payload_hash}
		* 				{}
	}

	## Create iRules
	set map "<MGMT_HOSTNAME> $mgmt_hostname
	   <MGMT_PORT> $mgmt_port
	   <HSL_POOL> ${app}_send_vs_pool
	   <ANALYTICS_HOSTNAME> [iapp::substa host_arr($analytics_solution)]
	   <ANALYTICS_PATH> \{$path_arr($analytics_solution)\}
	   <ANALYTICS_POST> \{$post_arr($analytics_solution)\}
	   <WORKSPACE> $workspace
	   <KEY> $access_key
	   <LOG_TYPE> $log_type
	   <LOG_LEVEL> $log_level
	   <FMT_IRULE_NAME> ${app}_format_ir
	   <EXTRA_FORMAT> \{$extra_fmt_arr($analytics_solution)\}
	   <DATE_CMD> \{$date_arr($analytics_solution)\}
	   <EXTRA_CMDS> \{$extra_cmd_arr($analytics_solution)\}
	   <REGION> $aws_region
	   <CONFIGURE_AUTH> \{$auth_proc_arr($analytics_solution)\}
	   <TABLE_SEQ> \{$seq_table_arr($analytics_solution)\}
	   <LOG_GROUP_NAME> $log_group_name
	   <LOG_STREAM_NAME> $log_stream_name
	   <REMED_LINK> \{$remediation_link\}
	   <IAPP_NAME> \{$app\}
	"

	set extra_map "<LOG_GROUP_NAME> $log_group_name
	   <LOG_STREAM_NAME> $log_stream_name
	"
	iapp::conf create ltm rule ${app}_format_ir \{ [string map $extra_map [string map $map $format_ir]] \}
	iapp::conf create ltm rule ${app}_send_ir \{ [string map $extra_map [string map $map $send_ir]] \}
	iapp::conf create ltm rule ${app}_cred_ir \{ [string map $extra_map [string map $map $cred_ir]] \}

	## Create objects to handle securely getting "secret" into data-plane runtime environment
	# Create https credential monitor
	iapp::conf create ltm monitor https ${app}_credential_mon defaults-from https username user password [iapp::make_safe_password [string trim $secret_key]] send 'GET /credentials \\r\\n' interval 30 timeout 61
	# Create credential client SSL profile
	iapp::conf create ltm profile client-ssl ${app}_cred_cssl \{ defaults-from clientssl \}
	# Create credential pool
	iapp::conf create ltm pool ${app}_cred_pool \{ members replace-all-with \{ 255.255.255.254:${cred_vs_port} \{ address 255.255.255.254 \} \} monitor ${app}_credential_mon \}
	# Create credential virtual server
	iapp::conf create ltm virtual ${app}_cred_vs \{ destination 255.255.255.254:${cred_vs_port} ip-protocol tcp mask 255.255.255.255 profiles replace-all-with \{ http \{\} oneconnect \{\} ${app}_cred_cssl \{ context clientside \} tcp \{ \} \} source 0.0.0.0/0 rules \{ ${app}_cred_ir \} \}

	# TCP profile (short idle time-out to force the last event message out of the Format VS iRule buffer)
	iapp::conf create ltm profile tcp ${app}_logging_tcp \{ defaults-from tcp idle-timeout 15 \}
	# Create server SSL profile for Send VS
	iapp::conf create ltm profile server-ssl ${app}_send_sssl \{ cert ${app}_send_vs_cert.crt defaults-from serverssl-insecure-compatible key ${app}_send_vs_cert.key \}

	# Point to Send VS via this pool
	iapp::conf create ltm pool ${app}_send_vs_pool \{ members replace-all-with \{ 255.255.255.254:${send_vs_port} \{ address 255.255.255.254 \} \} monitor tcp \}

	# create analytics solution pool
	# Keys: $analytics_solution
	array set pool_arr {
		azure_oms { [iapp::conf create ltm pool ${app}_logging_offbox \{ members replace-all-with \{ [format_poolmembers [string map {" " ""} [iapp::substa host_arr($analytics_solution)]:443]] \} monitor tcp \}] }
		aws_cw { [iapp::conf create ltm pool ${app}_logging_offbox \{ members replace-all-with \{ [format_poolmembers [string map {" " ""} [iapp::substa host_arr($analytics_solution)]:443]] \} monitor tcp \}] }
		aws_s3 { [iapp::conf create ltm pool ${app}_logging_offbox \{ members replace-all-with \{ [format_poolmembers [string map {" " ""} [iapp::substa host_arr($analytics_solution)]:443]] \} monitor tcp \}] }
		* {}
	}

	# Create Format and Send VS
	iapp::conf create ltm virtual ${app}_format_vs \{ destination 255.255.255.254:${format_vs_port} ip-protocol tcp mask 255.255.255.255 source 0.0.0.0/0 profiles replace-all-with \{ ${app}_logging_tcp \} rules \{${app}_format_ir \}\}
	iapp::conf create ltm virtual ${app}_send_vs \{ destination 255.255.255.254:${send_vs_port} ip-protocol tcp mask 255.255.255.255 pool [iapp::substa pool_arr($analytics_solution)] profiles replace-all-with \{ http \{\} oneconnect \{\} ${app}_send_sssl \{ context serverside \} tcp \{ \} \} source 0.0.0.0/0 source-address-translation \{ type automap \} rules \{ ${app}_send_ir \}\}


	# Logging publisher(s) and pool(s) required for some log sources
	if { $dos_logs || $apm_log_choice || $ltm_req_log_choice || $afm_log_choice } {
		iapp::conf create ltm pool ${app}_format_pool \{ members replace-all-with \{ 255.255.255.254:${format_vs_port} \{ address 255.255.255.254 \} \} monitor tcp \}

		iapp::conf create sys log-config destination remote-high-speed-log ${path}/${app}_dest_logger \{ pool-name ${path}/${app}_format_pool \}
		iapp::conf create sys log-config destination splunk ${path}/${app}_fmt_logger \{  forward-to ${path}/${app}_dest_logger \}
		iapp::conf create sys log-config publisher /Common/${app}_publisher \{ destinations replace-all-with \{ ${path}/${app}_fmt_logger \{ \} \} \}
	}

	## ASM/AFM can share the same remote logging profile, as such simply check what was selected
	## in the iApp and append to a single security logging profile.
	# ASM logging profile
	# Keys: $::logging_config__asm_log_level
	array set asm_log_req_arr {
		log_illegal { illegal }
		log_illegal_plus_staged { illegal-including-staged-signatures }
		log_all { all }
	}
	# Keys: $asm_log_choice
	array set asm_log_arr {
		1 { application replace-all-with \{ ${app}_remote_logging \{ local-storage disabled filter replace-all-with \{ protocol \{ values replace-all-with \{ all \} \} request-type \{ values replace-all-with \{ [iapp::substa asm_log_req_arr($::logging_config__asm_log_level)] \} \} search-all \{ \} \} maximum-entry-length 10k remote-storage splunk servers replace-all-with \{ 255.255.255.254:${format_vs_port} \{ \} \} \} \} }
		* { }
	}
	# Keys: $dos_logs
	array set dos_log_arr {
		1 { dos-application replace-all-with \{ ${app}_remote_l7dos_logging \{ local-publisher none remote-publisher /Common/${app}_publisher \} \} }
		* { }
	}
	# AFM logging profile
	# Keys: $afm_log_choice
	array set afm_log_arr {
		1 { network replace-all-with \{ ${app}_remote_logging \{ publisher /Common/${app}_publisher filter \{ log-acl-match-drop [expr {[lsearch $::logging_config__afm_log_level "match_drop"] != -1 ? "enabled" : "disabled" }] log-acl-match-reject [expr {[lsearch $::logging_config__afm_log_level "match_reject"] != -1 ? "enabled" : "disabled" }] log-acl-match-accept [expr {[lsearch $::logging_config__afm_log_level "match_accept"] != -1 ? "enabled" : "disabled" }] \} \} \} }
		* { }
	}

	# Create Security (ASM/AFM) logging profile
	if { $asm_log_choice || $afm_log_choice } {
		iapp::conf create security log profile ${app}_remote_logging [iapp::substa asm_log_arr($asm_log_choice)] [iapp::substa dos_log_arr($dos_logs)] [iapp::substa dos_log_arr($dos_logs)] [iapp::substa afm_log_arr($afm_log_choice)]
	}
	# Create APM logging profile
	if { $apm_log_choice } {
		set apm_lg_lvl $::logging_config__apm_log_level
		# Add some additional logging options available in v13.x and above
		if { $is_v13_0 } {
			set apm_opt_items "endpoint-management-system $apm_lg_lvl paa $apm_lg_lvl vdi $apm_lg_lvl"
		} else {
			set apm_opt_items ""
		}
		iapp::conf create apm log-setting ${app}_remote_logging access replace-all-with \{ access \{ log-level \{ access-control $apm_lg_lvl access-per-request $apm_lg_lvl apm-acl $apm_lg_lvl eca $apm_lg_lvl oauth $apm_lg_lvl sso $apm_lg_lvl swg $apm_lg_lvl $apm_opt_items \} publisher /Common/${app}_publisher \} \} url-filters replace-all-with \{ urlf \{ filter \{ log-allowed-url false log-blocked-url true log-confimed-url true  \} publisher /Common/${app}_publisher \} \}
	}
	# Create LTM request logging profile
	if { $ltm_req_log_choice } {
		# Format what is sent as key/value pairs in the same format as the "splunk" keyword on the BIG-IP is
		# sent that way it will be processed in the same manner
		# The list of request logging parameters are available here: https://support.f5.com/kb/en-us/products/big-ip_ltm/manuals/product/bigip-external-monitoring-implementations-12-0-0/3.html
		set ltm_req_log_template [format_req_logging $::logging_config__ltm_req_log_options]
		iapp::conf create ltm profile request-log ${app}_remote_logging defaults-from request-log request-log-pool ${path}/${app}_format_pool request-log-protocol mds-tcp request-log-template $ltm_req_log_template request-logging enabled
	}

	iapp::template stop
            }
            macro {
            }
            presentation {
                include "/Common/f5.apl_common"
section intro {
        # APL choice values may be set even if the optional
        # clause is not true. This trick is useful for setting
        # values that APL otherwise would not have access to.
        # Here, system provisioning values are recalled, and later
        # used to customize messages displayed within the template.
        optional ( "HIDE" == "THIS" ) {
            choice asm_provisioned tcl {
                return [expr {[iapp::get_provisioned asm] ? "yes" : "no"}]
            }
            choice apm_provisioned tcl {
                return [expr {[iapp::get_provisioned apm] ? "yes" : "no"}]
            }
            choice afm_provisioned tcl {
                return [expr {[iapp::get_provisioned afm] ? "yes" : "no"}]
            }
            choice is_admin tcl {
                return [expr { [iapp::get_user -is_admin] ? "yes" : "no"}]
            }
            choice is_v13_0 tcl {
                return [expr {[iapp::tmos_version >= 13.0] ? "yes" : "no"}]
            }
        }
        message hello "This iApp configures logging for BIG-IP modules to be sent to a specific set of cloud analytics solutions.  The solution creates logging profiles which can be manually attached to the appropriate objects (like virtual servers and APM policies) which results in logs being sent to the selected cloud analytics solution. Note: Be aware this may (depending on level of logging required) affect performance of the BIG-IP as a result of the processing required to construct and send the log messages over HTTP to the cloud analytics solution."
    }
section basic {
        choice advanced display "xxlarge" default "no" {
            "Basic - Use F5's recommended settings" => "no"  ,
            "Advanced - Configure advanced options" => "yes"
        }
        choice help display "xxlarge" default "hide" {
            "Yes, show inline help" => "show"  ,
            "No, do not show inline help" => "hide"
        }
        optional ( help == "show" ) {
            message help_max "Inline help is available to provide contextual descriptions to aid in the completion of this configuration.  Select to show or hide the inline help in this template. Important notes and warnings are always visible, no matter which selection you make here. "
        }
}
section analytics_config {
        choice analytics_solution display "xlarge" default "azure_oms" {
            "Azure (OMS)" => "azure_oms"  ,
            "AWS (S3)" => "aws_s3",
			"AWS (CloudWatch)" => "aws_cw"
        }
		optional ( basic.help == "show" ) {
            message analytics_solution_help "Select the analytics solution you are using.  The template creates logging profiles which can be manually attached to BIG-IP configuration objects which are then sent to the analytics solution you choose here."
        }
		optional ( analytics_solution == "aws_cw" ) {
			message analytics_aws_cw_help "AWS CloudWatch is an available logging destination, however to send data to it requires a synchronous flow of events.  This means that if trying to send to the same CloudWatch Logs Stream from two different devices or if there are a large number of logs being sent in a short time frame some of them will be lost."
		}
		optional ( analytics_solution == "azure_oms" ) {
			optional ( basic.advanced == "yes" ) {
				choice azure_env display "xlarge" default "azure" {
					"Azure" => "azure",
					"Azure US Government" => "azureusgov"
				}
				optional ( basic.help == "show" ) {
					message azure_env_help "Select which Azure environment you are deploying into."
				}
			}
            string workspace display "xxlarge" required
            optional ( basic.help == "show" ) {
                message workspace_help "Type your Azure OMS workspace ID."
            }
            password shared_key display "xxlarge" required
            optional ( basic.help == "show" ) {
                message shared_key_help "Type the primary or secondary shared key for the OMS workspace."
            }
            string log_type display "large" default "F5CustomLog" required
            message log_type_value_help "The log type cannot contain special or numeric characters."
            optional ( basic.help == "show" ) {
                message log_type_help "The log type you enter here is used as the log type when submitting to Azure OMS. You can then search for logs based on the log type name plus '_CL', for example: F5CustomLog_CL."
            }
        }
        optional ( analytics_solution == "aws_cw" || analytics_solution == "aws_s3" ) {
            choice aws_region display "large" default "us-west-1" {"us-west-1", "us-west-2", "us-east-1", "us-east-2", "ca-central-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-southeast-1", "ap-southeast-2", "eu-central-1", "eu-west-1", "eu-west-2", "sa-east-1"}
            optional ( basic.help == "show" ) {
                message aws_region_help "Select the AWS region for the provider you want to log to."
            }
            string access_key display "xxlarge" required
            optional ( basic.help == "show" ) {
                message access_key_help "Type the access key to use for the API calls."
            }
            password secret_key display "xxlarge" required
            optional ( basic.help == "show" ) {
                message secret_key_help "Type the secret key to use for the API calls."
            }
        }
		optional ( analytics_solution == "aws_cw") {
            string log_group_name display "xlarge" required
            optional ( basic.help == "show" ) {
                message log_group_name_help "Type the group name for your AWS CloudWatch Logs."
            }
            string log_stream_name display "xlarge" required
            optional ( basic.help == "show" ) {
                message log_stream_name_help "Type the group stream name for your AWS Cloud Watch Logs."
            }
		}
		optional ( analytics_solution == "aws_s3") {
            string s3_bucket_name display "xlarge" required
            optional ( basic.help == "show" ) {
                message s3_bucket_name_help "Type the name of the S3 bucket where the logs should be sent"
            }
		}
}
section logging_config {
        optional ( intro.asm_provisioned == "yes" ) {
            choice asm_log_choice display "xlarge" default "yes" {
                "Enable ASM logging" => "yes"  ,
                "Do not enable ASM logging" => "no"
            }
            optional ( basic.help == "show" ) {
                message asm_log_choice_help "Select whether you want to enable logging for the BIG-IP ASM (Application Security Manager) module. After deploying this template, you must attach the Security log profile created by this iApp to the applicable BIG-IP virtual servers (on the Security Tab)."
            }
            optional ( asm_log_choice == "yes" ) {
                choice asm_log_level display "xlarge" default "log_illegal" {
                    "Log illegal requests only (recommended)" => "log_illegal",
                    "Log illegal requests and staged signatures" => "log_illegal_plus_staged",
                    "Log all requests (verbose)" => "log_all"
                }
                optional ( basic.help == "show" ) {
                    message asm_log_level_help "Select the level of ASM logging you want to use. Note that logging illegal requests only results in the least number of log messages."
                }
                choice dos_logs display "xlarge" default "yes" {
                    "Include DOS protection logging" => "yes",
                    "Do not include DOS protection logging" => "no"
                }
                optional ( basic.help == "show" ) {
                    message dos_logs_help "Select whether you want to include DOS logging within the ASM logging profile."
                }
            }
        }
        optional ( intro.apm_provisioned == "yes" ) {
            choice apm_log_choice display "xlarge" default "yes" {
                "Enable APM logging" => "yes"  ,
                "Do not enable APM logging" => "no"
            }
            optional ( basic.help == "show" ) {
                message apm_log_choice_help "Select whether you want to enable logging for the BIG-IP APM (Application Policy Manager) module.  After deploying this template, you must attach the APM log profile created by this iApp to the applicable BIG-IP APM policies."
            }
            optional ( apm_log_choice == "yes" ) {
                choice apm_log_level display "xlarge" default "crit" {
                    "Emergency" => "emerg",
                    "Alert" => "alert",
                    "Critical" => "crit",
                    "Error" => "err",
                    "Warning" => "warn",
                    "Notice" => "notice",
                    "Informational" => "info",
                    "Debug" => "debug"
                }
                optional ( basic.help == "show" ) {
                    message apm_log_level_help "Select the level of APM logging you want to use. This log level is applied to all policy options in the APM logging profile.  Note: Choosing a higher criticality level results in fewer log messages."
                }
            }
        }
        optional ( intro.afm_provisioned == "yes" ) {
            choice afm_log_choice display "xlarge" default "yes" {
                "Enable AFM logging" => "yes"  ,
                "Do not enable AFM logging" => "no"
            }
            optional ( basic.help == "show" ) {
                message afm_log_choice_help "Select whether you want to enable logging for the BIG-IP AFM (Application Firewall Manager) module. After deploying this template, you must attach the Security log profile created by this iApp to the applicable BIG-IP virtual servers (on the Security Tab)."
            }
            optional ( afm_log_choice == "yes" ) {
                multichoice afm_log_level display "xlarge" default { "match_drop", "match_reject" } {
                    "Dropped Connections" => "match_drop",
                    "Rejected Connections" => "match_reject",
                    "Accepted Connections" => "match_accept"
                }
                optional ( basic.help == "show" ) {
                    message afm_log_level_help "Select the level of AFM logging you want to use. We recommend logging dropped and rejected requests only, which results in the least number of log messages."
                }
            }
        }
        choice ltm_req_log_choice display "xlarge" default "no" {
            "Enable LTM request logging" => "yes"  ,
            "Do not enable LTM request logging" => "no"
        }
        optional ( basic.help == "show" ) {
            message ltm_req_log_choice_help "Select whether you want to enable BIG-IP LTM (Local Traffic Manager) request logging. After deploying this template, you must attach the LTM request log profile created by this iApp to the applicable BIG-IP virtual servers."
        }
        optional ( ltm_req_log_choice == "yes" ) {
            multichoice ltm_req_log_options display "xlarge" default { "CLIENT_IP", "SERVER_IP", "HTTP_METHOD", "HTTP_URI", "VIRTUAL_NAME" } {
                "CLIENT_IP" => "CLIENT_IP",
                "CLIENT_PORT" => "CLIENT_PORT",
                "SERVER_IP" => "SERVER_IP",
                "HTTP_METHOD" => "HTTP_METHOD",
                "HTTP_URI" => "HTTP_URI",
                "HTTP_QUERY" => "HTTP_QUERY",
                "HTTP_VERSION" => "HTTP_VERSION",
                "VIRTUAL_IP" => "VIRTUAL_IP",
                "VIRTUAL_PORT" => "VIRTUAL_PORT",
                "VIRTUAL_NAME" => "VIRTUAL_NAME",
                "VIRTUAL_POOL_NAME" => "VIRTUAL_POOL_NAME"
            }
            optional ( basic.help == "show" ) {
                message ltm_req_log_options_help "Select which request parameters to send in the log message. The complete list and descriptions can be found at: https://support.f5.com/kb/en-us/products/big-ip_ltm/manuals/product/bigip-external-monitoring-implementations-12-0-0/3.html."
            }
        }
}
section internal_config {
        choice hostname display "xxlarge" default "yes" {
            "Use this BIG-IP's management hostname" => "yes"  ,
            "Use a custom BIG-IP management hostname" => "custom"
        }
        optional ( basic.help == "show" ) {
            message hostname_help "Select whether you want the iApp to use the management hostname configured on this BIG-IP system in items such as the ASM remediation link included with the ASM logs, or if you want to specify a custom management hostname.  We recommend using the BIG-IP hostname, unless the management hostname within a URL will not resolve correctly in DNS.  The custom hostname field allows you to enter a specific hostname that is different from the actual hostname on the BIG-IP system. "
        }
        optional ( hostname == "custom" ) {
            string mgmt_hostname display "xxlarge" default "bigip.f5.com" required
            optional ( basic.help == "show" ) {
                message mgmt_hostname_help "Type custom management hostname you want to use. "
            }
        }
        
        choice port display "xxlarge" default "yes" {
            "Use this BIG-IP's management port" => "yes"  ,
            "Use a custom BIG-IP management port" => "custom"
        }
        optional ( basic.help == "show" ) {
            message port_help "Select whether you want the iApp to use the management port configured on this BIG-IP system in items such as the ASM remediation link included with the ASM logs, or if you want to specify a custom management port."
        }
        optional ( port == "custom" ) {
            string mgmt_port display "small" validator "PortNumber" default "443" required
            optional ( basic.help == "show" ) {
                message mgmt_port_help "Type the custom management port you want to use."
            }
        }
        
        optional ( basic.advanced == "yes" ) {
			string internal_vs_port display "small" validator "PortNumber" default "41001" required
			optional ( basic.help == "show" ) {
				message internal_vs_port_help "Type first port to use for the internal virtual servers. The port you enter, plus the next 2 ports immediately following it are used by the solution."
			}
            choice irule_log_level display "xlarge" default "2" {
                "Log debug messages" => "0"  ,
                "Log info messages" => "1"  ,
                "Log only errors" => "2"
            }
            optional ( basic.help == "show" ) {
                message irule_log_level_help "The solution has internal logging built-in to help troubleshooting during initial setup as well as during operational use. The higher the logging level, fewer messages are sent to /var/log/ltm."
            }
        }
}
text {
    intro "F5 cloud logging and analytics solution"
    intro.hello "Introduction"

    basic "Template Options"
    basic.advanced "Which configuration mode do you want to use?"
    basic.help "Do you want to see inline help?"
    basic.help_max "Help"

    analytics_config "Analytics Provider"
    analytics_config.analytics_solution "Which analytics solution are you using?"
    analytics_config.analytics_solution_help ""
	analytics_config.analytics_aws_cw_help ""
    analytics_config.azure_env "Which Azure environment are you deploying into?"
	analytics_config.azure_env_help ""
	analytics_config.workspace "What is the Azure OMS workspace ID?"
    analytics_config.workspace_help ""
    analytics_config.shared_key "What is the shared access key (primary or secondary) for the Azure OMS workspace?"
    analytics_config.shared_key_help ""
    analytics_config.log_type "What would you like the log type to be called?"
    analytics_config.log_type_value_help ""
    analytics_config.log_type_help ""
    analytics_config.aws_region "Which AWS region is the provider located in?"
    analytics_config.aws_region_help ""
    analytics_config.log_group_name "What is the AWS CloudWatch Logs group name?"
    analytics_config.log_group_name_help ""
	analytics_config.s3_bucket_name "What is the AWS S3 bucket name?"
    analytics_config.s3_bucket_name_help ""
    analytics_config.log_stream_name "What is the AWS CloudWatch Logs group's stream name?"
    analytics_config.log_stream_name_help ""
    analytics_config.access_key "What is the access key you want to use for the API calls?"
    analytics_config.access_key_help ""
    analytics_config.secret_key "What is the secret key you want to use for the API calls?"
    analytics_config.secret_key_help ""

    logging_config "Log Selection"
    logging_config.asm_log_choice "Do you want to enable ASM logging?"
    logging_config.asm_log_choice_help ""
    logging_config.asm_log_level "What ASM requests do you want to log?"
    logging_config.asm_log_level_help ""
    logging_config.dos_logs "Do you want to include ASM DOS logging?"
    logging_config.dos_logs_help ""
    logging_config.apm_log_choice "Do you want to enable APM logging?"
    logging_config.apm_log_choice_help ""
    logging_config.apm_log_level "What level of APM logging do you want to use?"
    logging_config.apm_log_level_help ""
    logging_config.afm_log_choice "Do you want to enable AFM logging?"
    logging_config.afm_log_choice_help ""
    logging_config.afm_log_level "What AFM requests do you want to log?"
    logging_config.afm_log_level_help ""
    logging_config.ltm_req_log_choice "Do you want to enable LTM Request logging?"
    logging_config.ltm_req_log_choice_help ""
    logging_config.ltm_req_log_options "What Request parameters do you want to send in the log?"
    logging_config.ltm_req_log_options_help ""

    internal_config "Solution Configuration"
    internal_config.hostname "Use this BIG-IP system's management hostname or a custom hostname?"
    internal_config.hostname_help ""
    internal_config.mgmt_hostname "What is the mgmt FQDN or IP you want to use?"
    internal_config.mgmt_hostname_help ""
    internal_config.port "Use this BIG-IP system's management port or a custom port?"
    internal_config.port_help ""
    internal_config.mgmt_port "What is the mgmt port you want to use?"
    internal_config.mgmt_port_help ""
    internal_config.internal_vs_port "What should be the start port for internal virtual servers?"
	internal_config.internal_vs_port_help ""
    internal_config.irule_log_level "What level of internal logging do you want this solution to use (for debug/info during testing)?"
     internal_config.irule_log_level_help ""
}
        }
        role-acl { admin manager resource-admin }
        run-as none
        }
    }
    description none
    ignore-verification false
    requires-bigip-version-max none
    requires-bigip-version-min 12.1
    requires-modules none
    signing-key none
    tmpl-checksum none
    tmpl-signature none
}

