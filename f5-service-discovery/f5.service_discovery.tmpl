sys application template /Common/f5.service_discovery {
    actions {
        definition {
            html-help {
                <p><b>Service Discovery Template</b></p>
<p>This template creates a complete configuration for updating pool members based on auto-scaled cloud application hosts. Before you start: </p>
<ul>
    <li>All of the help for this iApp template is found inline. Select <b>Yes, show inline help</b> from the inline help question.</li>
    <li>Check System :: Resource Provisioning to ensure that LTM (local traffic manager) is provisioned.</li>
    <li>Set up VLANs to the servers containing the applications your clients will access.</li>
</ul>
            }
            implementation {
                package require iapp 1.3.0

                set service_discovery_rpm_min_version 1.0.0-1
                set service_discovery_tag v$service_discovery_rpm_min_version

                proc verify_hash { file_path } {
                    if {[catch {
                        set hashes(f5-service-discovery-1.0.0-1.noarch.rpm) 0da952dfd7ee1caca1d09729ccefc4e076a5dba736172cc293c05e967500dd8e77e09ef3f2c44fb452f182d93e332a7ad124414bb3d045ad157fa37e1a65a1ea

                        set file_name [file tail $file_path]

                        if { ![info exists hashes($file_name)] } {
                            tmsh::log err "No hash found for $file_name"
                            error "No hash found for $file_name"
                            exit 1
                        }

                        set expected_hash $hashes($file_name)
                        set computed_hash [lindex [exec /usr/bin/openssl dgst -r -sha512 $file_path] 0]
                        if { $expected_hash ne $computed_hash } {
                            tmsh::log err "Invalid hash for $file_name"
                            error "Invalid hash for $file_name"
                            exit 1
                        }
                    } err ]} {
                        tmsh::log err "Unexpected error in verifyHash: $err"
                        error "Unexpected error in verifyHash: $err"
                        exit 1
                    }
                }

                proc compare_versions { version1 version2 } {
                    set version1_parts [split $version1 .]
                    set version2_parts [split $version2 .]

                    if  { $version1 eq $version2 } {
                        return 0
                    }

                    set index 0
                    while { [lindex $version1_parts $index] == [lindex $version2_parts $index] } {
                        if { $index == [llength $version1_parts] } {
                            break
                        }
                        set index [expr {$index + 1}]
                    }

                    if { $index == [llength $version1_parts] } {
                        return 0
                    }

                    if { [lindex $version1_parts $index] > [lindex $version2_parts $index] } {
                        return 1
                    }

                    if { [lindex $version1_parts $index] == [lindex $version2_parts $index] } {
                        return 0
                    }

                    return -1
                }

                proc get_installed_version { path } {
                    set version {}
                    if { [string match */node_modules/* $path]
                         || [string match /var/config/rest/iapps/* $path] } {
                        # if it's a node package...
                        set version [exec /bin/cat $path/package.json | /usr/bin/jq -r .version]
                    } else {
                        puts "Unknown file type $path"
                    }
                    return $version
                }

                proc download { url file_name dest_path } {
                    set download_dir /var/config/rest/downloads
                    set mgmt_port [tmsh::get_config sys httpd ssl-port]
                    set mgmt_port [regexp -all -inline {\d+} $mgmt_port]

                    set download_path $download_dir/$file_name

                    if { [catch {
                        exec /bin/mkdir -p $dest_path

                        puts "Downloading $url"
                        exec /usr/bin/curl -s -o $download_path $url

                        puts "Verifying $download_path"
                        verify_hash $download_path
                    } err ]} {
                        tmsh::log err "Error downloading $url: $err"
                        error "Error downloading $url: $err"
                        exit 1
                    }
                }

                proc install { full_path availability_check } {
                    if { [catch {
                        puts "Installing $full_path"
                        if { [string match *.rpm $full_path] } {
                            set body_map "
                                <FULL_PATH> $full_path
                            "
                            set body {{"operation": "INSTALL", "packageFilePath": "<FULL_PATH>"}}
                            set body [string map $body_map $body]

                            set task_id [exec /usr/bin/curl -sku admin: -X POST -d $body https://localhost/mgmt/shared/iapp/package-management-tasks | jq -r .id]

                            # wait till it is done installing
                            set status ''
                            set num_tries 50
                            while { $status != "FINISHED" && $num_tries != 0 } {
                                set status [exec /usr/bin/curl -sku admin: https://localhost/mgmt/shared/iapp/package-management-tasks/$task_id | jq -r .status]
                                incr num_tries -1
                            }

                            # wait till it is available
                            set status [exec /usr/bin/curl -sku admin: $availability_check]
                            set num_tries 50
                            while { $status != "{}" && $num_tries != 0 } {
                                set status [exec /usr/bin/curl -sku admin: $availability_check]
                                incr num_tries -1
                            }

                            if { $status == "{}" } {
                                puts "Installed $full_path"
                            } else {
                                tmsh::log err "$full_path never became available"
                                error "$full_path never became available"
                                exit 1
                            }

                        } else {
                            tmsh::log err "Unknown file type $full_path"
                            error "Unknown file type $full_path"
                            exit 1
                        }
                    } err ]} {
                        tmsh::log err "Error installing $full_path: $err"
                        error "Error installing $full_path: $err"
                        exit 1
                    }
                }

                proc is_install_required { dependencies } {
                    set needs_install 0

                    # figure out if we need to install anything
                    foreach dependency $dependencies {
                        set path [lindex $dependency 0]
                        set min_version [lindex $dependency 1]
                        set download_url [lindex $dependency 2]

                        set file_name [file tail $download_url]

                        puts "checking $path"
                        if { ![file exists $path] } {
                            # if the file doesn't exist at all, download it
                            puts "$path does not exist. Will install."
                            set needs_install 1
                        } else {
                            # check to see if a recent enough version is installed

                            set installed_version [get_installed_version $path]

                            if { [string length $installed_version] == 0 } {
                                puts "Could not get version of $path_to_check $file_name"
                                exit 1
                            }

                            if { [compare_versions $installed_version $min_version] < 0 } {
                                puts "$path_to_check $file_name is too old. Will install."
                                set needs_install 1
                            }
                        }
                    }

                    return $needs_install
                }

                proc install_dependencies { cloud_provider } {
                    puts "Checking dependencies"

                    upvar 1 service_discovery_rpm_min_version service_discovery_rpm_min_version
                    upvar 1 service_discovery_tag service_discovery_tag

                    set common_install_prefix /var/config/rest/iapps
                    set sd_install_dir $common_install_prefix/f5-service-discovery

                    # each element in list is a list of 'location_to_search min_acceptable_version download_url availability_check_url'
                    set dependencies [list \
                        [list $sd_install_dir $service_discovery_rpm_min_version https://cdn.f5.com/product/cloudsolutions/f5-service-discovery/$service_discovery_tag/f5-service-discovery-$service_discovery_rpm_min_version.noarch.rpm https://localhost/mgmt/shared/service-discovery/task/available] \
                    ]

                    if { [is_install_required $dependencies] == 1 } {
                        puts "Installing dependencies"
                        foreach dependency $dependencies {
                            set path [lindex $dependency 0]
                            set download_url [lindex $dependency 2]
                            set availability_check [lindex $dependency 3]

                            set file_name [file tail $download_url]
                            set dest_path /var/config/rest/downloads

                            download $download_url $file_name $dest_path
                            install $dest_path/$file_name $availability_check
                        }
                    }
                }

                # splits a string into a list of chunks of a specified length
                proc chunk { data chunk_length } {
                    set start 0
                    set length [string length $data]
                    lappend chunks
                    while { $start + $chunk_length <= $length } {
                        set end [expr $start + $chunk_length - 1]
                        lappend chunks [string range $data $start $end]
                        incr start $chunk_length
                    }

                    if { $start < $length } {
                        lappend chunks [string range $data $start [expr $length - 1]]
                    }

                    return $chunks
                }

                # The service discovery worker expects encrypted data to be encrypted MCP configuration
                # values. For large data, this must be broken up into comma separated chunks.
                proc encrypt { data app_name } {
                    set encrypted {}
                    set chunks [chunk $data 500]
                    foreach chunk $chunks {
                        exec /usr/bin/tmsh create auth radius-server $app_name secret $chunk server foo
                        set radius_info [exec /usr/bin/tmsh list auth radius-server $app_name]
                        regexp {secret\s+([^\s]+)} $radius_info -> encrypted_chunk
                        if { $encrypted ne "" } {
                            append encrypted ,
                        }
                        append encrypted $encrypted_chunk
                        exec /usr/bin/tmsh delete auth radius-server $app_name
                    }

                    return $encrypted
                }

                # These functions are not used, but must be here for people upgrading from older versions
                proc url_encode {} {}
                proc url_init {} {}

                iapp::template start

                install_dependencies $::cloud__cloud_provider

                # constants
                set YES_ANSWER "yes"
                set NO_ANSWER "no"
                set CREATE_NEW_ANSWER "/#create_new#"
                set DEFAULT_ANSWER "/#default#"

                set app $tmsh::app_name
                set advanced [expr { [iapp::is ::basic__advanced $YES_ANSWER] }]
                set lb_lcm_licensed [expr {[string first ltm_lb_least_conn [tmsh::show sys license detail]] != -1}]

                # MONITOR SEND STRING
                # only the first FQDN in the hosts table is used for monitoring
                set hostname   [lindex [join [join [expr { [info exists ::pool__hosts] \
                               ? "$::pool__hosts" : "" }]]] 1]
                set http10     [iapp::is ::monitor__http_version http10]
                set http_post  [iapp::is ::monitor__http_method POST]

                # array keys: $http10,$http_post
                array set send_string_arr {
                    1,1 { 'POST $::monitor__uri HTTP/1.0\\r\\nContent-Length: [string length $::monitor__post_body]\\r\\n\\r\\n$::monitor__post_body' }
                    1,0 { 'GET $::monitor__uri HTTP/1.0\\r\\n\\r\\n' }
                    0,1 { 'POST $::monitor__uri HTTP/1.1\\r\\nHost: $hostname\\r\\nContent-Length: [string length $::monitor__post_body]\\r\\nConnection: Close\\r\\n\\r\\n$::monitor__post_body' }
                    *   { 'GET $::monitor__uri HTTP/1.1\\r\\nHost: $hostname\\r\\nConnection: Close\\r\\n\\r\\n'}
                }

                set partition [lindex [split [tmsh::pwd] /] 1]

                # MONITOR
                set new_monitor [iapp::is ::monitor__monitor $::CREATE_NEW_ANSWER]
                set http_or_https [expr { [iapp::is ::monitor__type https] ? {https}:{http} }]

                # array keys: $new_pool,$new_monitor
                array set monitor_arr {
                    1,1 { monitor [iapp::conf create ltm monitor $http_or_https \
                        ${app}_${http_or_https}_monitor \
                        defaults-from $http_or_https \
                        interval $::monitor__frequency \
                        timeout [expr { $::monitor__frequency * 3 + 1 } ] \
                        send [iapp::substa send_string_arr($http10,$http_post)]\
                        recv '$::monitor__response'] }
                    1,0 { monitor $::monitor__monitor }
                    *   { monitor none }
                }

                # POOL
                # array keys: $advanced,$lb_lcm_licensed
                array set pool_lb_method {
                    0,0 { load-balancing-mode round-robin }
                    0,1 { load-balancing-mode least-connections-member }
                    *   { load-balancing-mode $::pool__lb_method_choice }
                }

                set new_pool [iapp::is ::pool__pool_to_use "/#create_new#"]
                if { $new_pool } {
                    set pool_name /${partition}/${app}.app/${app}_pool
                } else {
                    set pool_name $::pool__pool_to_use
                }

                # array keys: $new_pool,tcp
                array set pool {
                    1,tcp { pool [iapp::conf create ltm pool ${app}_pool \
                                 [iapp::substa pool_lb_method($advanced,$lb_lcm_licensed)] \
                                 [iapp::substa monitor_arr($new_pool,$new_monitor)] ] }

                    *     { pool $::pool__pool_to_use }
                }

                iapp::substa pool($new_pool,tcp)

                if { [iapp::is ::cloud__aws_bigip_in_ec2 $YES_ANSWER] } {
                    set ::cloud__aws_access_key_id $DEFAULT_ANSWER
                    set ::cloud__aws_secret_access_key $DEFAULT_ANSWER
                }

                if { [iapp::is ::cloud__aws_use_role $NO_ANSWER] } {
                    set ::cloud__aws_role_arn $DEFAULT_ANSWER
                    set ::cloud__aws_external_id $DEFAULT_ANSWER
                }

                if { [iapp::is ::cloud__gce_bigip_in_gc $YES_ANSWER] } {
                    set ::cloud__gce_credentials_json_base64 $DEFAULT_ANSWER
                }

                switch $::cloud__cloud_provider {
                    aws {
                        append provider_options "{"
                        append provider_options {"tagKey": "<MEMBER_TAG_KEY>",}
                        append provider_options {"tagValue": "<MEMBER_TAG_VALUE>",}
                        append provider_options {"addressRealm": "<ADDRESS_TYPE>",}
                        append provider_options {"region": "<REGION>"}

                        if { ![iapp::is ::cloud__aws_role_arn $DEFAULT_ANSWER] } {
                            append provider_options {,}
                            append provider_options {"roleARN": "<ROLE_ARN>"}
                        }

                        if { ![iapp::is ::cloud__aws_external_id $DEFAULT_ANSWER] } {
                            append provider_options {,}
                            append provider_options {"externalId": "<EXTERNAL_ID>"}
                        }

                        if { [iapp::is ::cloud__aws_bigip_in_ec2 $NO_ANSWER] } {
                            append provider_options {,}
                            append provider_options {"accessKeyId": "<ACCESS_KEY_ID>",}
                            append provider_options {"secretAccessKey": "<SECRET_ACCESS_KEY>"}
                        }

                        append provider_options "}"

                        set provider_options_map "
                            <MEMBER_TAG_KEY>      $::pool__tag_key
                            <MEMBER_TAG_VALUE>    $::pool__tag_value
                            <ADDRESS_TYPE>        $::pool__public_private
                            <ROLE_ARN>            $::cloud__aws_role_arn
                            <EXTERNAL_ID>         $::cloud__aws_external_id
                        "

                        if { [iapp::is ::cloud__aws_bigip_in_ec2 $NO_ANSWER] } {
                            set encrypted [encrypt $::cloud__aws_secret_access_key $tmsh::app_name]
                            append provider_options_map "
                                <REGION>              $::cloud__aws_region_req
                                <ACCESS_KEY_ID>       $::cloud__aws_access_key_id
                                <SECRET_ACCESS_KEY>   $encrypted
                            "
                        } else {
                            append provider_options_map "
                                <REGION>              $::cloud__aws_region
                            "
                        }

                        set provider_options [string map $provider_options_map $provider_options]
                    }
                    azure {
                        append provider_options "{"
                        append provider_options {"tagKey": "<MEMBER_TAG_KEY>",}
                        append provider_options {"tagValue": "<MEMBER_TAG_VALUE>",}
                        append provider_options {"addressRealm": "<ADDRESS_TYPE>",}
                        append provider_options {"resourceGroup": "<RESOURCE_GROUP>",}
                        append provider_options {"subscriptionId": "<SUBSCRIPTION_ID>",}
                        append provider_options {"tenantId": "<TENANT_ID>",}
                        append provider_options {"clientId": "<CLIENT_ID>",}
                        append provider_options {"apiAccessKey": "<SP_SECRET>"}

                        if { [iapp::is ::cloud__azure_bigip_in_environment $NO_ANSWER] } {
                            append provider_options {,}
                            append provider_options {"environment": "<ENVIRONMENT>"}
                        }

                        append provider_options "}"

                        set encrypted [encrypt $::cloud__azure_sp_secret $tmsh::app_name]

                        set provider_options_map "
                            <MEMBER_TAG_KEY>      $::pool__tag_key
                            <MEMBER_TAG_VALUE>    $::pool__tag_value
                            <ADDRESS_TYPE>        $::pool__public_private
                            <RESOURCE_GROUP>      $::cloud__azure_resource_group
                            <SUBSCRIPTION_ID>     $::cloud__azure_subscription_id
                            <TENANT_ID>           $::cloud__azure_tenant_id
                            <CLIENT_ID>           $::cloud__azure_client_id
                            <SP_SECRET>           $encrypted
                        "

                        if { [iapp::is ::cloud__azure_bigip_in_environment $NO_ANSWER] } {
                            append provider_options_map "
                                <ENVIRONMENT>     $::cloud__azure_environment
                            "
                        }

                        set provider_options [string map $provider_options_map $provider_options]
                    }
                    gce {
                        append provider_options "{"
                        append provider_options {"tagKey": "<MEMBER_TAG_KEY>",}
                        append provider_options {"tagValue": "<MEMBER_TAG_VALUE>",}
                        append provider_options {"addressRealm": "<ADDRESS_TYPE>",}
                        append provider_options {"region": "<REGION>"}

                        if { [iapp::is ::cloud__gce_bigip_in_gc $NO_ANSWER] } {
                            append provider_options {,}
                            append provider_options {"encodedCredentials": "<GC_CREDENTIALS>"}
                        }

                        append provider_options "}"

                        set provider_options_map "
                            <MEMBER_TAG_KEY>      $::pool__tag_key
                            <MEMBER_TAG_VALUE>    $::pool__tag_value
                            <ADDRESS_TYPE>        $::pool__public_private
                        "

                        if { [iapp::is ::cloud__gce_bigip_in_gc $NO_ANSWER] } {
                            set encrypted [encrypt $::cloud__gce_credentials_json_base64 $tmsh::app_name]
                            append provider_options_map "
                                <REGION>         $::cloud__gce_region_req
                                <GC_CREDENTIALS>  $encrypted
                            "
                        } else {
                            append provider_options_map "
                                <REGION>         $::cloud__gce_region
                            "
                        }

                        set provider_options [string map $provider_options_map $provider_options]
                    }
                }

                append post_body "{"
                append post_body     {"schemaVersion": "1.0.0",}
                append post_body     {"class": "ServiceDiscovery",}
                append post_body     {"id": "<TASK_ID>",}
                append post_body     {"updateInterval": <UPDATE_INTERVAL>,}
                append post_body     {"resources": [}
                append post_body         "{"
                append post_body             {"type": "pool",}
                append post_body             {"path": "<POOL_TO_USE>",}
                append post_body             {"options":}
                append post_body             "{"
                append post_body                 {"servicePort": <MEMBER_PORT>,}
                append post_body                 {"connectionLimit": <CONNECTION_LIMIT>}
                append post_body             "}"
                append post_body         "}"
                append post_body     {],}
                append post_body     {"provider": "<CLOUD>",}
                append post_body     {"providerOptions": {<PROVIDER_OPTIONS>},}
                append post_body     {"dependsOn": "sys application service <APP_NAME>"}
                append post_body "}"

                set post_body_map "
                    <CLOUD>               $::cloud__cloud_provider
                    <TASK_ID>             ${partition}_${app}.app_${app}
                    <APP_NAME>            /${partition}/${app}.app/${app}
                    <POOL_TO_USE>         $pool_name
                    <UPDATE_INTERVAL>     $::pool__interval
                    <MEMBER_PORT>         $::pool__member_port
                    <CONNECTION_LIMIT>    $::pool__member_conn_limit
                    <PROVIDER_OPTIONS>    $provider_options
                "

                # Delete any existing tasks for this iapp. The rest worker does not let us POST to an
                # existing task.
                puts "DELETE"
                set result [exec /usr/bin/curl -sku admin: -X DELETE https://localhost/mgmt/shared/service-discovery/task/${partition}_${app}.app_${app}?ignoreMissing=true]
                puts "RESPONSE $result"

                set post_body [string map $post_body_map $post_body]
                set post_body [regsub -all $DEFAULT_ANSWER $post_body {}]
                puts "POST $post_body"
                set result [exec /usr/bin/curl -sku admin: -X POST  -H "Content-Type: application/json" -H "Expect:" -d $post_body https://localhost/mgmt/shared/service-discovery/task?skipFirstRun=true]
                puts "RESPONSE $result"

                # we need strict updates off so that the rest worker can update the pool
                tmsh::modify sys application service /${partition}/${app}.app/${app} strict-updates disabled

                iapp::template stop
            }
            macro {
            }
            presentation {
                define choice lb_method display "xxlarge" tcl {
                    if { [string first ltm_lb_least_conn [tmsh::show sys license detail]] != -1 } {
                        set choices "Least Connections (member)\tleast-connections-member\nLeast Connections (node)\tleast-connections-node\nLeast Sessions\tleast-sessions\nFastest (application)\tfastest-app-response\nFastest (node)\tfastest-node\nObserved (member)\tobserved-member\nObserved (node)\tobserved-node\nPredictive (member)\tpredictive-member\nPredictive (node)\tpredictive-node\nRound Robin\tround-robin\nWeighted Least Connections (member)\tweighted-least-connections-member"
                    } else {
                        set choices "Round Robin\tround-robin"
                    }
                    return $choices
                }

                section intro {
                    message intro
                    message note
                    message tag
                    message tag1
                    message tag2
                    message tag3
                    message tag4

                    optional ( intro == "NEVER_SHOW_THIS" ) {
                        choice isa_dmin tcl {
                            package require iapp 1.1.3
                            return [expr { [iapp::get_user -is_admin] ? "yes" : "no"}]
                        }
                    }
                }

                section basic {
                    choice advanced display "xxlarge" default "no"
                    choice display_help display "xxlarge" default "hide"
                }

                section cloud {
                    choice cloud_provider display "xxlarge"
                        optional ( basic.display_help == "max" ) {
                            message cloud_provider_help
                        }

                    optional ( cloud_provider == "aws" ) {
                        choice aws_bigip_in_ec2 default "yes" display "xxlarge"
                            optional ( basic.display_help == "max" ) {
                                message aws_bigip_in_ec2_help
                            }
                        optional ( aws_bigip_in_ec2 == "no" ) {
                            string aws_access_key_id required display "xxlarge"
                            password aws_secret_access_key required display "xxlarge"
                            choice aws_region_req display "xxlarge"
                        }
                        optional ( aws_bigip_in_ec2 == "yes" ) {
                            choice aws_region display "xxlarge"
                        }
                        optional ( basic.display_help == "max" ) {
                            message aws_region_help
                        }

                        choice aws_use_role default "no" display "xxlarge"
                            optional ( basic.display_help == "max" ) {
                                message aws_use_role_help
                            }
                        optional ( aws_use_role == "yes" ) {
                            string aws_role_arn required display "xxlarge"
                            string aws_external_id required display "xxlarge"
                        }
                    }

                    optional ( cloud_provider == "azure" ) {
                        choice azure_bigip_in_environment default "yes" display "xxlarge"
                            optional ( basic.display_help == "max" ) {
                                message azure_bigip_in_environment_help
                            }
                        optional ( azure_bigip_in_environment == "no" ) {
                            choice azure_environment display "xxlarge"
                        }
                         string azure_resource_group required display "xxlarge"
                         optional ( basic.display_help == "max" ) {
                            message azure_resource_group_help
                        }
                        string azure_subscription_id required display "xxlarge"
                        string azure_tenant_id required display "xxlarge"
                        string azure_client_id required display "xxlarge"
                        password azure_sp_secret required display "xxlarge"
                        optional ( basic.display_help == "max" ) {
                             message azure_auth_help
                        }
                    }

                    optional ( cloud_provider == "gce" ) {
                        choice gce_bigip_in_gc default "yes" display "xxlarge"
                            optional ( basic.display_help == "max" ) {
                                message gce_bigip_in_gc_help
                            }
                        optional ( gce_bigip_in_gc == "no" ) {
                            password gce_credentials_json_base64 required display "xxlarge"
                            choice gce_region_req display "xxlarge"
                        }
                        optional ( gce_bigip_in_gc == "yes" ) {
                            choice gce_region display "xxlarge"
                        }
                        optional ( basic.display_help == "max" ) {
                            message gce_region_help
                        }
                    }
                }

                section pool {
                    string tag_key required display "xxlarge"
                        optional ( basic.display_help == "max" ) {
                            message tag_key_help
                        }
                    string tag_value required display "xxlarge"
                    choice public_private display "xxlarge" default "private" {
                        "Public IP addresses" => "public" ,
                        "Private IP addresses" => "private"
                    }
                    string interval required default "60"

                    choice pool_to_use display "xxlarge" default "/#create_new#" tcl {
                        package require iapp 1.0.0
                        set ::choices "/#create_new#\n[iapp::get_items ltm pool]"
                        return [iapp::safe_display ::choices]
                    }
                    optional ( basic.display_help == "max" ) {
                        message pool_help
                    }

                    string member_port display "small" required default "80" validator "PortNumber"
                    optional ( basic.display_help == "max" ) {
                        message member_port_help
                    }

                    string member_conn_limit display "small" required default "0" validator "NonNegativeNumber"
                    optional ( basic.display_help == "max" ) {
                        message member_conn_limit_help
                    }

                    optional ( basic.advanced == "yes" ) {
                        lb_method lb_method_choice

                        optional ( basic.display_help == "max" ) {
                            message lb_method_max
                        }
                    }
                }

                optional ( pool.pool_to_use == "/#create_new#" ) {

                    section monitor {

                        choice monitor display "xxlarge" default "/#create_new#" tcl {

                            set ::choices "Create a new health monitor\t/#create_new#\n[iapp::get_items ltm monitor http]\n[iapp::get_items ltm monitor https]"
                            return [iapp::safe_display ::choices]
                        }
                            optional ( basic.display_help == "max" ) {
                                message monitor_help
                            }
                        optional ( monitor == "/#create_new#" ) {

                            choice type display "xxlarge" default "http" {
                                        "HTTP" => "http"  ,
                                        "HTTPS" => "https"
                            }
                                optional ( basic.display_help == "max" ) {
                                        message type_help
                                }
                            string uri display "xxlarge" required default "/"
                                optional ( basic.display_help == "max" ) {
                                    message uri_help
                                }
                            string frequency display "medium" required default "30" validator "NonNegativeNumber"
                                optional ( basic.display_help == "max" ) {
                                    message frequency_help
                                }
                            choice http_version display "xxlarge" default "http11" {
                                        "HTTP/1.0" => "http10"  ,
                                        "HTTP/1.1" => "http11"
                            }
                                optional ( basic.display_help == "max" ) {
                                    message http_version_help
                                }
                            choice http_method display "xxlarge" default "GET" { "GET"  , "POST" }
                                optional ( basic.display_help == "max" ) {
                                    message http_method_help
                                }
                            optional ( http_method == "POST" ) {
                                string post_body display "xxlarge" required

                                optional ( basic.display_help == "max" ) {
                                    message post_body_help
                                }
                            }
                            string response display "xxlarge"
                                optional ( basic.display_help == "max" ) {
                                    message response_help
                                }
                        }
                    }
                }

                text {
                    intro "Welcome to the iApp template for Cloud Service Discovery"
                    intro.intro "Introduction" "This iApp enables automatically updating pool members based on auto-scaled cloud application hosts.  Once you have tagged your cloud resources appropriately, complete this template and then the BIG-IP VE will programmatically discover (or remove) pool members based on the tags."
                    intro.note "IMPORTANT" "This iApp uses the tag key and tag values you configure on your cloud provider to discover pool members. Make sure the tags and IP addresses you use are unique. You should not tag multiple nodes with the same key/tag combination if those nodes use the same IP address. See your cloud provider documentation for specific information on tagging."
                    intro.tag "Tagging your cloud resources" "You have the following options for tagging nodes on your cloud provider."
                    intro.tag1 "" " * Tag a VM resource:  If you tag a VM resource, the BIG-IP VE will discover the primary public or private IP address for the primary NIC configured for the tagged VM."
                    intro.tag2 "" " * Tag a NIC resource:  If you tag a NIC resource, the BIG-IP VE will discover the primary public or private IP addresses for the tagged NIC.  Use this option if you want to use the secondary NIC of a VM in the pool."
                    intro.tag3 "" " * (Azure only) Tag a Virtual Machine Scale Set resource:  If you tag a Scale Set resource, the BIG-IP VE will discover the primary private IP address for the primary NIC configured for each Scale Set instance.  Note you must select Private IP addresses if you are tagging a Scale Set."
                    intro.tag4 "" "The iApp first looks for NIC resources with the tags you specify.  If it finds NICs with the proper tags, it does not look for VM resources. If it does not find NIC resources, it looks for VM resources with the proper tags. If you are using Microsoft Azure only: In either case, it then looks for Scale Set resources with the proper tags."

                    basic "Template Options"
                    basic.display_help "Do you want to see inline help?" {
                        "Yes, show inline help" => "max",
                        "No, do not show inline help" => "hide"
                    }
                    basic.advanced "Which configuration mode do you want to use?" {
                        "Basic - Use F5's recommended settings" => "no",
                        "Advanced - Configure advanced options" => "yes"
                    }

                    cloud "Cloud Provider"
                    cloud.cloud_provider "In which cloud provider are the pool members deployed?" {
                        "AWS EC2" => "aws",
                        "Azure" => "azure",
                        "Google Compute Engine" => "gce"
                    }
                    cloud.cloud_provider_help "" "Select the cloud in which the BIG-IP VE (Virtual Edition) you are configuring is running."

                    cloud.aws_bigip_in_ec2 "Is your BIG-IP running in EC2?" {
                        "Yes" => "yes",
                        "No" => "no"
                    }
                    cloud.aws_bigip_in_ec2_help "" "If the BIG-IP is not running in EC2, we need to collect credentials."
                    cloud.aws_access_key_id "What is your AWS acess key id?"
                    cloud.aws_secret_access_key "What is your AWS secret access key?"

                    cloud.aws_region "Which region do you want to search for pool members?" {
                        "Default" => "/#default#",
                        "US East (N. Virginia)" => "us-east-1",
                        "US East (Ohio)" => "us-east-2",
                        "US West (N. California)" => "us-west-1",
                        "US West (Oregon)" => "us-west-2",
                        "Canada (Central)" => "ca-central-1",
                        "EU (Ireland)" => "eu-west-1",
                        "EU (Frankfurt)" => "eu-central-1",
                        "EU (London)" => "eu-west-2",
                        "Asia Pacific (Tokyo)" => "ap-northeast-1",
                        "Asia Pacific (Seoul)" => "ap-northeast-2",
                        "Asia Pacific (Singapore)" => "ap-southeast-1",
                        "Asia Pacific (Sydney)" => "ap-southeast-2",
                        "Asia Pacific (Mumbai)" => "ap-south-1",
                        "South America (São Paulo)" => "sa-east-1"
                    }
                    cloud.aws_region_req "Which region do you want to search for pool members?" {
                        "US East (N. Virginia)" => "us-east-1",
                        "US East (Ohio)" => "us-east-2",
                        "US West (N. California)" => "us-west-1",
                        "US West (Oregon)" => "us-west-2",
                        "Canada (Central)" => "ca-central-1",
                        "EU (Ireland)" => "eu-west-1",
                        "EU (Frankfurt)" => "eu-central-1",
                        "EU (London)" => "eu-west-2",
                        "Asia Pacific (Tokyo)" => "ap-northeast-1",
                        "Asia Pacific (Seoul)" => "ap-northeast-2",
                        "Asia Pacific (Singapore)" => "ap-southeast-1",
                        "Asia Pacific (Sydney)" => "ap-southeast-2",
                        "Asia Pacific (Mumbai)" => "ap-south-1",
                        "South America (São Paulo)" => "sa-east-1"
                    }
                    cloud.aws_region_help "" "Default is to search the same region in which the BIG-IP is running. If the BIG-IP is not running in EC2, you must select a region"
                    cloud.aws_use_role "Do you want to assume a role?" {
                        "Yes" => "yes",
                        "No" => "no"
                    }
                    cloud.aws_use_role_help "" "Assuming a role is typically used for cross-account access (for example if your Application servers are in one account and the BIG-IP VE is in another). If you select Yes, you must specify the ARN and External ID in the following questions. See the AWS documentation for details."
                    cloud.aws_role_arn "What is the role Amazon Resource Name (ARN)?"
                    cloud.aws_external_id "What is the External ID?"

                    cloud.azure_bigip_in_environment "Are your BIG-IP and pool members in the same Azure Environment?" {
                        "Yes" => "yes",
                        "No" => "no"
                    }
                    cloud.azure_bigip_in_environment_help "" "If your BIG-IP and pool members are in different Azure environments, we need the Azure Environment of the pool members"
                    cloud.azure_subscription_id "What is the subscription ID?"
                    cloud.azure_tenant_id "What is the tenant ID?"
                    cloud.azure_client_id "What is the client ID?"
                    cloud.azure_sp_secret "What is the service principal secret?"
                    cloud.azure_auth_help "" "Enter the service principal information used to search the Azure subscription for pool members. See https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-create-service-principal-portal for more information."
                    cloud.azure_resource_group "What is the Azure resource group?"
                    cloud.azure_resource_group_help "" "Type the name of the Azure resource group containing the tagged resources."

                    cloud.azure_environment "Which Azure Environment do you want to search for pool members?" {
                        "Azure" => "Azure",
                        "Azure China" => "AzureChina",
                        "Azure US Government" => "AzureUSGovernment",
                        "Azure German Cloud" => "AzureGermanCloud"
                    }

                    cloud.gce_bigip_in_gc "Is your BIG-IP running in Google Cloud?" {
                        "Yes" => "yes",
                        "No" => "no"
                    }
                    cloud.gce_bigip_in_gc_help "" "If the BIG-IP is not running in Google Cloud, we need to collect credentials."
                    cloud.gce_credentials_json_base64 "Enter the Base64 encoded credentials json"
                    cloud.gce_region "Which region do you want to search?" {
                        "Default" => "/#default#",
                        "US East 1" => "us-east1",
                        "US East 4" => "us-east4",
                        "US Central 1" => "us-central1",
                        "US West 1" => "us-west1",
                        "Europe West 1" => "eu-west1",
                        "Europe West 2" => "eu-west2",
                        "Europe West 3" => "eu-west3",
                        "Asia Northeast 1" => "asia-northeast1",
                        "Asia East 1" => "asia-east1",
                        "Asia Southeast 1" => "asia-southeast1",
                        "Australia Southeast 1" => "australia-southeast1"
                    }
                    cloud.gce_region_req "Which region do you want to search?" {
                        "US East 1" => "us-east1",
                        "US East 4" => "us-east4",
                        "US Central 1" => "us-central1",
                        "US West 1" => "us-west1",
                        "Europe West 1" => "eu-west1",
                        "Europe West 2" => "eu-west2",
                        "Europe West 3" => "eu-west3",
                        "Asia Northeast 1" => "asia-northeast1",
                        "Asia East 1" => "asia-east1",
                        "Asia Southeast 1" => "asia-southeast1",
                        "Australia Southeast 1" => "australia-southeast1"
                    }
                    cloud.gce_region_help "" "Default is to search the same region in which the BIG-IP is running."

                    pool "Pool"
                    pool.pool_to_use "Do you want to create a new pool or use an existing one?" {
                        "Create a new pool..." => "/#create_new#"
                    }
                    pool.pool_help "" "A load balancing pool is a logical set of devices, such as application servers, grouped together to receive and process traffic. When clients attempt to access the application via the BIG-IP virtual server, the BIG-IP system distributes requests to any of the servers that are members of that pool.  If you select an existing pool, we strongly recommend you have at least one health monitor attached.The iApp does not create a health monitor for existing pools."
                    pool.tag_key "What is the tag key on your cloud provider for the members of this pool?"
                    pool.tag_key_help "" "Type the cloud provider tag key and tag value for the members of your pool. Servers with these values are added to your pool."
                    pool.tag_value "What is the tag value on your cloud provider for the members of this pool?"
                    pool.public_private "Do you want to search for public or private IP addresses?"
                    pool.interval "How often do you want to query the cloud provider for updates (in seconds)?"
                    pool.member_port "Which port should be assigned to the pool members?"
                    pool.member_port_help "" "Type the port number you want assigned to the pool members.  Port 80 is the default."
                    pool.member_conn_limit "Connection limit (optional)"
                    pool.member_conn_limit_help "" "You can optionally specify a connection limit for the pool members.  When this limit is reached, the system no longer sends new connections to that member."
                    pool.lb_method_choice "Which load balancing method do you want to use?"
                    pool.lb_method_max "" "A load balancing method is an algorithm that the BIG-IP system uses to select a pool member for processing a request. F5 recommends the Least Connections load balancing method, where new connections are routed to the node that has the least number of current connections. This is ideal for environments in which pool members have similar performance and capacity capabilities."

                    monitor "Application Health"
                    monitor.monitor "Create a new health monitor or use an existing one?"
                    monitor.monitor_help "" "Monitors are used to determine the health of each server. If server does not respond or responds incorrectly, the system will cease to send client requests to that server. The system will continue to monitor the instance and will begin sending requests once the server responds correctly."
                    monitor.type "What monitor type should be used?"
                    monitor.type_help "The monitor type selected will determine what type of monitor to create, such as HTTP or HTTPS"
                    monitor.http_method "What type of HTTP request should be sent to the servers?"
                    monitor.http_method_help "" "The HTTP request type determines which HTTP method the monitor sends to the server. GET is the most common request type for web applications."
                    monitor.uri "What HTTP URI should be sent to the servers?"
                    monitor.uri_help "" "The HTTP URI is used to specify the resource on the server for a given request. This parameter can be customized to request a specific part of an application, which can indicate the health of the application on a granular level."
                    monitor.http_version "Which HTTP version do your servers expect clients to use?"
                    monitor.http_version_help "" "The HTTP version can be customized so it matches what a typical client would be using, in order to detect failures in the most meaningful way. HTTP/1.0 and HTTP/1.1 are the most common.  HTTP/1.0 is more simple, while HTTP/1.1 offers more features."
                    monitor.frequency "How many seconds should pass between health checks?"
                    monitor.frequency_help "" "This is the duration, in seconds, of a single monitor cycle. At this interval, the system checks the health of the server in the pool."
                    monitor.response "What is the expected response to the HTTP request?"
                    monitor.response_help "" "When the HTTP response arrives for a monitor request, its contents are searched for the value specified here. If it is not found, the monitoring attempt fails."
                    monitor.post_body "What HTTP POST body do you want to use for this monitor?"
                    monitor.post_body_help "" "POST requests require an HTTP POST body to send to the server."
                }
            }
            role-acl { admin manager resource-admin }
            run-as none
        }
    }
    description none
    ignore-verification false
    requires-bigip-version-max none
    requires-bigip-version-min 12.1.0
    requires-modules { ltm }
    signing-key /Common/f5-irule
    tmpl-checksum none
    tmpl-signature dzTif/UqJFfqFWLikwW48u9Z8eCaOyjmuqx0OA/sbsBUpUmsZohpNSGwzYI2BlC5Lk0awgdnT+Fav90LuZuOJmA01n6iG627s3kbJZeF86OJmy0L09JW4+5ta4c/QEH5u43TqM0Yb2YJisMD4YDt6JZyyW3Z4548N+3o/HR3cv85AB/CEGYBbBCUfIkj3ra1L/6IsRFW3Cv0/occz0By1I3BRXxAtvbVxc5iGvp1PgJmflspEXi+jK0A1SwLBTB+MbHp52P3a3c9yeyQj8mjCTKKvCKyUx+0WfuWJyMyvxauvgV69lHi5RcHwevrxABJuBdmziyXqgYFh1xmx0Wuqw==
}